## 脚本位置
因为html的dom不知道引入的js是否会对dom做处理,所以要等js加载完再解析页面 (所以需要把script标签放到body标签的底部)

内嵌的脚本放在引用外链样式表的link标签之后会导致页面阻塞去等待样式表的下载(内嵌的脚本不要跟在link标签后面)

## 组织脚本
下载单个100kb的文件比下载4个25kb的文件更快(减少页面中的外链脚本文件的数量，多个js可以合并成一个来引入)

## 无阻塞的脚本
下载单个较大的js文件会锁死浏览器一段时间(向页面中逐步加载js文件。页面加载完成后才加载js代码，换句话说，在window对象的load事件触发后再下载脚本)

## 延迟的脚本
script标签属性：defer、async  (必须有src属性才生效)
defer：指外部js文件和当前html页面同时加载（异步加载），但只在当前页面解析完成之后执行js代码
async：指外部js文件和当前html页面同时加载（异步加载），在当前js文件加载完成后，执行js代码

拥有defer属性和async属性的外部js文件属于异步加载，普通外部js文件属于同步加载。
异步加载：指同时加载，即某个js文件加载的同时，其余文件也可以加载
同步加载：指某个js文件加载的同时，其余文件不能加载

如果同时指定了两个属性，则会遵从async属性而忽略defer属性

推荐的应用场景:
defer
如果你的脚本代码依赖于页面中的DOM元素（文档是否渲染完毕），或者被其他脚本文件依赖。
例：
评论框
代码语法高亮
polyfill.js

async
如果你的脚本并不关心页面中的DOM元素（文档是否渲染完毕），并且也不会产生其他脚本需要的数据。
例：
百度统计
如果不太能确定的话，用defer总是会比async稳定。。。

## 动态脚本元素
用js创建一个script标签（无论何时启动下载，文件的下载和执行过程不会阻塞页面其它进程）
通过document.head可以获得<head>元素的引用

## XMLHttpRequest脚本注入（不能跨域，不推荐）
先创建一个XHR对象，然后用它下载js文件，最后通过创建动态<script>元素将代码注入页面中。